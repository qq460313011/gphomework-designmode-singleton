单例模式总结
1.饿汉式
静态常量，和静态代码块模式：优点是写法简单，保证了线程安全，因为是静态的，缺点是类一加载就要
完成对象的实例化，如果这种方式的单例对象很多，会造成资源大量浪费。
2.懒汉式
在调用时直接通过if判断：在单线程下可以使用，在多线程调用下，多个线程都进入if判断
导致单例失效
在方法上加synchronized:可以保证线程安全，但效率不高
双重check:保证了线程安全，但写法较复杂，要考虑序列化破坏单例的问题
静态内部类：写法简单，安全效率高，因为类静态属性只在第一次加载的时候初始化，jvm
保证了线程安全，需要考虑反射setAccessible设为true,导致私有构造函数被调用的问题
3.注册式
通过枚举：
枚举模式满足线程安全的原因是，ENUM_SINGLETON被声明为static,所以是线程安全的，java规范规定每一个枚举类型在其定义的jvm中都是唯一的
序列化时java仅仅是将枚举对象的name属性输出到结果中，反序列化的时候通过java.lang.enum的valueOf方法根据名字查枚举对象
也就是说序列化的时候只将DATASOURCE这个名字输出，反序列化的时候再通过这个名称，查找对应的枚举类型，因此序列化也不会破坏单例
容器式：学习spring将对象放在容器中
4.序列化式
通过懒汉式和重写readResolve保证反序列化不会影响单例实现
重写readResolve方法，防止序列化破坏单例,因为在ObjectInputStream中的readOrdinaryObject如果对象序列化了，会调用对象的无参构造方法
而重写readResolve方法，会在接下来判断，如果实例有readResolve方法会通过反射调用这个readResovle方法，在这个方法中返回之前的已经实例化的对象就可以避免序列化破坏单例
5.threadlocal
保证线程内部是单例唯一的


破坏单例模式的方式
1.序列化
由于反序列化内部的ObjectInputStream的readResolve的问题
2.反射
setAccessible设为true,导致私有构造函数被调用的问题